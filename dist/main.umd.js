(function(t,r){typeof exports=="object"&&typeof module<"u"?r(exports):typeof define=="function"&&define.amd?define(["exports"],r):(t=typeof globalThis<"u"?globalThis:t||self,r(t.__LAKE__={}))})(this,function(t){"use strict";var B=Object.defineProperty;var A=t=>{throw TypeError(t)};var F=(t,r,s)=>r in t?B(t,r,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[r]=s;var d=(t,r,s)=>F(t,typeof r!="symbol"?r+"":r,s),T=(t,r,s)=>r.has(t)||A("Cannot "+s);var h=(t,r,s)=>(T(t,r,"read from private field"),s?s.call(t):r.get(t)),U=(t,r,s)=>r.has(t)?A("Cannot add the same private member more than once"):r instanceof WeakSet?r.add(t):r.set(t,s),C=(t,r,s,E)=>(T(t,r,"write to private field"),E?E.call(t,s):r.set(t,s),s);var m,p,S,b,a;class r{constructor(n){U(this,m);C(this,m,n)}get value(){return h(this,m)}set value(n){C(this,m,n)}}m=new WeakMap;const s=e=>new r(e);class E{constructor(n){U(this,p);C(this,p,n)}get value(){return h(this,p).value}}p=new WeakMap;const _=e=>new E(e);function I(e,n){if(!e)throw new Error(n||"unexpected condition")}var l=(e=>(e.MOUNTED="Mounted",e.UNMOUNTED="Unmounted",e))(l||{});function R(e){return n=>{v(e)[e].push(n)}}const y=R("Mounted"),w=R("Unmounted");let M;const D=e=>(M=e,e);function v(e){return I(M,`"${e}" called outside setup() will never be run.`),M}let $=0;b=l.MOUNTED,S=l.UNMOUNTED;class x{constructor(n,o){d(this,b,[]);d(this,S,[]);d(this,"parent",null);U(this,a,[]);d(this,"uid");d(this,"current",{});d(this,"element");d(this,"onMount",()=>{const n=this[l.MOUNTED].map(o=>o()).filter(o=>typeof o=="function");this[l.UNMOUNTED].push(...n)});d(this,"onUnmount",()=>{[...this[l.UNMOUNTED],...h(this,a).flatMap(o=>o.onUnmount)].forEach(o=>o())});d(this,"addChild",n=>{h(this,a).push(n),n.parent=this,n.onMount()});d(this,"removeChild",n=>{const o=h(this,a).indexOf(n);o!==-1&&(h(this,a).splice(o,1),n.parent=null,n.onUnmount())});this.uid=`${o}.${$++}`,this.element=n}}a=new WeakMap;function O(e){const n=M;return(o,u)=>{const i=new x(o,e.name),c=D(i),f=e.setup(o,u);return c.current=f||{},D(n),c}}const N=new WeakMap;function W(e,n,o){if(N.has(e)){const u={payload:{el:e,component:n,name:o},reason:""};throw new Error(JSON.stringify(u))}try{N.set(e,n)}catch{const i={payload:{el:e,component:n,name:o},reason:""};throw new Error(JSON.stringify(i))}}function j(){return{component(e){return(n,o={})=>{const u=O(e)(n,o);return W(n,u,e.name),u.onMount(),u}},unmount(e){e.filter(n=>N.has(n)).forEach(n=>{N.get(n).onUnmount()})}}}const q=e=>e;function J(e,n,o,u){e.addEventListener(n,o,u),w(()=>{e.removeEventListener(n,o,u)})}const L=(e,n)=>Array.from((n??document).querySelectorAll(e));function P(e,n){const o=i=>{const c=L(`[data-ref="${i}"]`,n),{length:f}=c;return f===0?null:{1:c[0]}[f]??c};return[...e].reduce((i,c)=>(i[c]=o(c),i),{})}function g(...e){const n=v("useDomRef");return{refs:P(new Set(e),n.element)}}function k(e,n,o={rootMargin:"0px",threshold:.1}){const u=new IntersectionObserver(n,o),i=f=>{Array.isArray(f)?f.forEach(z=>u.observe(z)):u.observe(f)};return y(()=>{i(e)}),w(()=>{u.disconnect()}),{unwatch:f=>{u.unobserve(f)}}}function K(){const e=v("useSlot");return{addChild(n,o,u={}){const i=c=>{const f=O(o)(c,u);return e.addChild(f),f};return Array.isArray(n)?n.map(c=>i(c)):[i(n)]},removeChild(n){n.forEach(o=>e.removeChild(o))}}}function V(){return v("useRootRef").element}t.create=j,t.defineComponent=q,t.readonly=_,t.ref=s,t.useDomRef=g,t.useEvent=J,t.useIntersectionWatch=k,t.useMount=y,t.useRootRef=V,t.useSlot=K,t.useUnmount=w,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})});
