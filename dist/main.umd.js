(function(t,r){typeof exports=="object"&&typeof module<"u"?r(exports):typeof define=="function"&&define.amd?define(["exports"],r):(t=typeof globalThis<"u"?globalThis:t||self,r(t.__LAKE__={}))})(this,function(t){"use strict";var z=Object.defineProperty;var A=t=>{throw TypeError(t)};var B=(t,r,s)=>r in t?z(t,r,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[r]=s;var f=(t,r,s)=>B(t,typeof r!="symbol"?r+"":r,s),T=(t,r,s)=>r.has(t)||A("Cannot "+s);var h=(t,r,s)=>(T(t,r,"read from private field"),s?s.call(t):r.get(t)),N=(t,r,s)=>r.has(t)?A("Cannot add the same private member more than once"):r instanceof WeakSet?r.add(t):r.set(t,s),U=(t,r,s,E)=>(T(t,r,"write to private field"),E?E.call(t,s):r.set(t,s),s);var m,p,S,b,a;class r{constructor(n){N(this,m);U(this,m,n)}get value(){return h(this,m)}set value(n){U(this,m,n)}}m=new WeakMap;const s=e=>new r(e);class E{constructor(n){N(this,p);U(this,p,n)}get value(){return h(this,p).value}}p=new WeakMap;const _=e=>new E(e);function I(e,n){if(!e)throw new Error(n||"unexpected condition")}var l=(e=>(e.MOUNTED="Mounted",e.UNMOUNTED="Unmounted",e))(l||{});function y(e){return n=>{w(e)[e].push(n)}}const D=y("Mounted"),C=y("Unmounted");let M;const O=e=>(M=e,e);function w(e){return I(M,`"${e}" called outside setup() will never be run.`),M}let $=0;b=l.MOUNTED,S=l.UNMOUNTED;class W{constructor(n,o){f(this,b,[]);f(this,S,[]);f(this,"parent",null);N(this,a,[]);f(this,"uid");f(this,"current",{});f(this,"element");f(this,"onMount",()=>{const n=this[l.MOUNTED].map(o=>o()).filter(o=>typeof o=="function");this[l.UNMOUNTED].push(...n)});f(this,"onUnmount",()=>{[...this[l.UNMOUNTED],...h(this,a).flatMap(o=>o.onUnmount)].forEach(o=>o())});f(this,"addChild",n=>{h(this,a).push(n),n.parent=this,n.onMount()});f(this,"removeChild",n=>{const o=h(this,a).indexOf(n);o!==-1&&(h(this,a).splice(o,1),n.parent=null,n.onUnmount())});this.uid=`${o}.${$++}`,this.element=n}}a=new WeakMap;function R(e){const n=M;return(o,u)=>{const i=new W(o,e.name),c=O(i),d=e.setup(o,u);return c.current=d||{},O(n),c}}const v=new WeakMap;function j(e,n,o){if(v.has(e)){const u={payload:{el:e,component:n,name:o},reason:""};throw new Error(JSON.stringify(u))}try{v.set(e,n)}catch{const i={payload:{el:e,component:n,name:o},reason:""};throw new Error(JSON.stringify(i))}}function q(){return{component(e){return(n,o={})=>{const u=R(e)(n,o);return j(n,u,e.name),u.onMount(),u}},unmount(e){e.filter(n=>v.has(n)).forEach(n=>{v.get(n).onUnmount()})}}}const x=e=>e;function J(e,n,o,u){e.addEventListener(n,o,u),C(()=>{e.removeEventListener(n,o,u)})}const L=(e,n)=>Array.from((n??document).querySelectorAll(e));function P(e,n){const o=i=>{const c=L(`[data-ref="${i}"]`,n),{length:d}=c;return d===0?null:{1:c[0]}[d]??c};return[...e].reduce((i,c)=>(i[c]=o(c),i),{})}function g(...e){const n=w("useDomRef");return{refs:P(new Set(e),n.element)}}function k(e,n,o={rootMargin:"0px",threshold:.1}){const u=new IntersectionObserver(n,o),i=d=>{Array.isArray(d)?d.forEach(V=>u.observe(V)):u.observe(d)};return D(()=>{i(e)}),C(()=>{u.disconnect()}),{unwatch:d=>{u.unobserve(d)}}}function K(){const e=w("useSlot");return{addChild(n,o,u={}){const i=c=>{const d=R(o)(c,u);return e.addChild(d),d};return Array.isArray(n)?n.map(c=>i(c)):[i(n)]},removeChild(n){n.forEach(o=>e.removeChild(o))}}}t.create=q,t.defineComponent=x,t.readonly=_,t.ref=s,t.useDomRef=g,t.useEvent=J,t.useIntersectionWatch=k,t.useMount=D,t.useSlot=K,t.useUnmount=C,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})});
