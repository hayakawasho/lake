var B=Object.defineProperty;var F=(t,o,c)=>o in t?B(t,o,{enumerable:!0,configurable:!0,writable:!0,value:c}):t[o]=c;var i=(t,o,c)=>(F(t,typeof o!="symbol"?o+"":o,c),c),$=(t,o,c)=>{if(!o.has(t))throw TypeError("Cannot "+c)};var f=(t,o,c)=>($(t,o,"read from private field"),c?c.call(t):o.get(t)),C=(t,o,c)=>{if(o.has(t))throw TypeError("Cannot add the same private member more than once");o instanceof WeakSet?o.add(t):o.set(t,c)},N=(t,o,c,p)=>($(t,o,"write to private field"),p?p.call(t,c):o.set(t,c),c);(function(t,o){typeof exports=="object"&&typeof module<"u"?o(exports):typeof define=="function"&&define.amd?define(["exports"],o):(t=typeof globalThis<"u"?globalThis:t||self,o(t.__LAKE__={}))})(this,function(t){var h,v,g,z,l;"use strict";class o{constructor(n){C(this,h,void 0);N(this,h,n)}get value(){return f(this,h)}set value(n){N(this,h,n)}}h=new WeakMap;const c=e=>new o(e);class p{constructor(n){C(this,v,void 0);N(this,v,n)}get value(){return f(this,v).value}}v=new WeakMap;const A=e=>new p(e);function O(e,n){if(!e)throw new Error(n||"unexpected condition")}const U=e=>e.forEach(n=>n());var m=(e=>(e.MOUNTED="Mounted",e.UNMOUNTED="Unmounted",e))(m||{});const y=e=>n=>{R(e)[e].push(n)},T=y("Mounted"),E=y("Unmounted");let M;const D=e=>M=e,R=e=>(O(M,`"${e}" called outside setup() will never be run.`),M);let _=0;class I{constructor(n,r){i(this,g,[]);i(this,z,[]);i(this,"parent",null);C(this,l,[]);i(this,"uid");i(this,"current",{});i(this,"mount",()=>{U(this[m.MOUNTED])});i(this,"unmount",()=>{U([...this[m.UNMOUNTED],...f(this,l).flatMap(n=>n.unmount)])});i(this,"addChild",n=>{f(this,l).push(n),n.parent=this,n.mount()});i(this,"removeChild",n=>{const r=f(this,l).indexOf(n);r!==-1&&(f(this,l).splice(r,1),n.parent=null,n.unmount())});this.element=n,this.uid=`${r}.${_++}`}}g=m.MOUNTED,z=m.UNMOUNTED,l=new WeakMap;const S=e=>{const n=M;return(r,s)=>{const a=new I(r,e.name),u=D(a),d=e.setup(r,s);return u.current=d||{},D(n),u}},w=new WeakMap,x=(e,n,r)=>{if(w.has(e)){console.error(`${r} was already bind.`);return}w.set(e,n)},W=()=>({component(e){return(n,r={})=>{const s=S(e)(n,r);return x(n,s,e.name),s.mount(),s}},unmount(e){e.filter(n=>w.has(n)).forEach(n=>w.get(n).unmount())}}),b=e=>e,j=(e,n,r,s)=>{e.addEventListener(n,r,s),E(()=>{e.removeEventListener(n,r,s)})},L=(e,n)=>Array.from((n??document).querySelectorAll(e));function P(e,n){const r=u=>{const d=L(`[data-ref="${u}"]`,n);return s(d)},s=u=>({0:null,1:u[0]})[u.length]??u;return[...e].reduce((u,d)=>(u[d]=r(d),u),{})}function k(...e){const n=R("DomRef");return{refs:P(new Set(e),n.element)}}const q=(e,n,r={rootMargin:"0px",threshold:.1})=>{const s=new IntersectionObserver(n,r);return Array.isArray(e)?e.forEach(u=>s.observe(u)):s.observe(e),E(()=>{s.disconnect()}),{unwatch:u=>{s.unobserve(u)}}},K=()=>{const e=R("Slot");return{addChild(n,r,s={}){const a=u=>{const d=S(r)(u,s);return e.addChild(d),d};return Array.isArray(n)?n.map(u=>a(u)):[a(n)]},removeChild(n){n.forEach(r=>e.removeChild(r))}}};function V(e,n="withSvelte"){return b({name:n,setup(r,s){const a=new Map([["$",{rootRef:r,...s}]]),u=new e({target:r,context:a});E(()=>{u.$destroy()})}})}t.create=W,t.defineComponent=b,t.readonly=A,t.ref=c,t.useDomRef=k,t.useEvent=j,t.useIntersectionWatch=q,t.useMount=T,t.useSlot=K,t.useUnmount=E,t.withSvelte=V,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})});
