var V=Object.defineProperty;var z=(t,r,s)=>r in t?V(t,r,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[r]=s;var f=(t,r,s)=>(z(t,typeof r!="symbol"?r+"":r,s),s),S=(t,r,s)=>{if(!r.has(t))throw TypeError("Cannot "+s)};var h=(t,r,s)=>(S(t,r,"read from private field"),s?s.call(t):r.get(t)),N=(t,r,s)=>{if(r.has(t))throw TypeError("Cannot add the same private member more than once");r instanceof WeakSet?r.add(t):r.set(t,s)},U=(t,r,s,E)=>(S(t,r,"write to private field"),E?E.call(t,s):r.set(t,s),s);(function(t,r){typeof exports=="object"&&typeof module<"u"?r(exports):typeof define=="function"&&define.amd?define(["exports"],r):(t=typeof globalThis<"u"?globalThis:t||self,r(t.__LAKE__={}))})(this,function(t){var m,p,g,k,a;"use strict";class r{constructor(n){N(this,m,void 0);U(this,m,n)}get value(){return h(this,m)}set value(n){U(this,m,n)}}m=new WeakMap;const s=e=>new r(e);class E{constructor(n){N(this,p,void 0);U(this,p,n)}get value(){return h(this,p).value}}p=new WeakMap;const b=e=>new E(e);function A(e,n){if(!e)throw new Error(n||"unexpected condition")}var l=(e=>(e.MOUNTED="Mounted",e.UNMOUNTED="Unmounted",e))(l||{});function y(e){return n=>{w(e)[e].push(n)}}const D=y("Mounted"),C=y("Unmounted");let M;const O=e=>M=e;function w(e){return A(M,`"${e}" called outside setup() will never be run.`),M}let T=0;class _{constructor(n,o){f(this,g,[]);f(this,k,[]);f(this,"parent",null);N(this,a,[]);f(this,"uid");f(this,"current",{});f(this,"onMount",()=>{const n=this[l.MOUNTED].map(o=>o()).filter(o=>typeof o=="function");this[l.UNMOUNTED].push(...n)});f(this,"onUnmount",()=>{[...this[l.UNMOUNTED],...h(this,a).flatMap(o=>o.onUnmount)].forEach(o=>o())});f(this,"addChild",n=>{h(this,a).push(n),n.parent=this,n.onMount()});f(this,"removeChild",n=>{const o=h(this,a).indexOf(n);o!==-1&&(h(this,a).splice(o,1),n.parent=null,n.onUnmount())});this.element=n,this.uid=`${o}.${T++}`}}g=l.MOUNTED,k=l.UNMOUNTED,a=new WeakMap;function R(e){const n=M;return(o,u)=>{const i=new _(o,e.name),c=O(i),d=e.setup(o,u);return c.current=d||{},O(n),c}}const v=new WeakMap;function I(e,n,o){if(v.has(e)){const u={payload:{el:e,component:n,name:o},reason:""};throw new Error(JSON.stringify(u))}try{v.set(e,n)}catch{const i={payload:{el:e,component:n,name:o},reason:""};throw new Error(JSON.stringify(i))}}function $(){return{component(e){return(n,o={})=>{const u=R(e)(n,o);return I(n,u,e.name),u.onMount(),u}},unmount(e){e.filter(n=>v.has(n)).forEach(n=>v.get(n).onUnmount())}}}const x=e=>e;function W(e,n,o,u){e.addEventListener(n,o,u),C(()=>{e.removeEventListener(n,o,u)})}const j=(e,n)=>Array.from((n??document).querySelectorAll(e));function q(e,n){const o=i=>{const c=j(`[data-ref="${i}"]`,n),{length:d}=c;return d===0?null:{1:c[0]}[d]??c};return[...e].reduce((i,c)=>(i[c]=o(c),i),{})}function J(...e){const n=w("useDomRef");return{refs:q(new Set(e),n.element)}}function L(e,n,o={rootMargin:"0px",threshold:.1}){const u=new IntersectionObserver(n,o),i=d=>{Array.isArray(d)?d.forEach(K=>u.observe(K)):u.observe(d)};return D(()=>{i(e)}),C(()=>{u.disconnect()}),{unwatch:d=>{u.unobserve(d)}}}function P(){const e=w("useSlot");return{addChild(n,o,u={}){const i=c=>{const d=R(o)(c,u);return e.addChild(d),d};return Array.isArray(n)?n.map(c=>i(c)):[i(n)]},removeChild(n){n.forEach(o=>e.removeChild(o))}}}t.create=$,t.defineComponent=x,t.readonly=b,t.ref=s,t.useDomRef=J,t.useEvent=W,t.useIntersectionWatch=L,t.useMount=D,t.useSlot=P,t.useUnmount=C,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})});
